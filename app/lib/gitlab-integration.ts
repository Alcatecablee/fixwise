/**
 * GitLab Integration for NeuroLint
 * Provides GitLab CI/CD pipeline integration with NeuroLint analysis
 */

export interface GitLabConfig {
  gitlabUrl: string;
  projectId: string;
  accessToken: string;
  branch: string;
  webhookSecret: string;
}

export interface GitLabPipelineConfig {
  stages: {
    checkout: boolean;
    install: boolean;
    analyze: boolean;
    test: boolean;
    deploy: boolean;
  };
  neuroLintConfig: {
    layers: number[];
    failOnIssues: boolean;
    maxIssues: number;
    outputFormat: 'json' | 'html' | 'junit';
    includePatterns: string[];
    excludePatterns: string[];
  };
  notifications: {
    email?: string[];
    slack?: string;
    teams?: string;
  };
}

export class GitLabIntegration {
  private config: GitLabConfig;

  constructor(config: GitLabConfig) {
    this.config = config;
  }

  /**
   * Generate GitLab CI pipeline configuration
   */
  generatePipelineConfig(pipelineConfig: GitLabPipelineConfig): string {
    const { stages, neuroLintConfig, notifications } = pipelineConfig;
    
    return `# NeuroLint CI/CD Pipeline
# Generated by NeuroLint GitLab Integration

stages:
  ${stages.checkout ? '- checkout' : ''}
  ${stages.install ? '- install' : ''}
  - analyze
  ${stages.test ? '- test' : ''}
  ${stages.deploy ? '- deploy' : ''}

variables:
  NEUROLINT_VERSION: "1.2.1"
  NEUROLINT_WEBHOOK_URL: "${this.config.webhookSecret}"

${stages.checkout ? this.generateCheckoutJob() : ''}
${stages.install ? this.generateInstallJob() : ''}
${this.generateAnalyzeJob(neuroLintConfig)}
${stages.test ? this.generateTestJob() : ''}
${stages.deploy ? this.generateDeployJob() : ''}
${this.generateNotificationJobs(notifications)}`;
  }

  /**
   * Generate checkout job
   */
  private generateCheckoutJob(): string {
    return `checkout:
  stage: checkout
  script:
    - echo "Checking out code from ${this.config.branch}"
  only:
    - ${this.config.branch}`;
  }

  /**
   * Generate install job
   */
  private generateInstallJob(): string {
    return `install:
  stage: install
  script:
    - |
      if [ -f "package.json" ]; then
        npm ci
      fi
      if [ -f "yarn.lock" ]; then
        yarn install --frozen-lockfile
      fi
  artifacts:
    paths:
      - node_modules/
    expire_in: 1 hour
  only:
    - ${this.config.branch}`;
  }

  /**
   * Generate analyze job
   */
  private generateAnalyzeJob(config: any): string {
    const { layers, failOnIssues, maxIssues, outputFormat, includePatterns, excludePatterns } = config;
    
    return `analyze:
  stage: analyze
  image: node:18-alpine
  before_script:
    - npm install -g @neurolint/cli@$NEUROLINT_VERSION
  script:
    - |
      echo "Running NeuroLint analysis..."
      neurolint analyze . \\
        --layers=${layers.join(',')} \\
        --format=${outputFormat} \\
        --output=neurolint-results.${outputFormat} \\
        --include="${includePatterns.join(',')}" \\
        --exclude="${excludePatterns.join(',')}" \\
        --verbose
      
      # Process results
      if [ -f "neurolint-results.json" ]; then
        ISSUE_COUNT=$(jq '.issues | length' neurolint-results.json)
        echo "Found $ISSUE_COUNT issues"
        
        # Send webhook notification if issues found
        if [ "$ISSUE_COUNT" -gt 0 ]; then
          curl -X POST $NEUROLINT_WEBHOOK_URL \\
            -H "Content-Type: application/json" \\
            -H "X-Webhook-Secret: $NEUROLINT_WEBHOOK_SECRET" \\
            -d @neurolint-results.json
        fi
        
        # Fail if configured to do so
        ${failOnIssues ? `if [ "$ISSUE_COUNT" -gt ${maxIssues} ]; then
          echo "Too many issues found: $ISSUE_COUNT > ${maxIssues}"
          exit 1
        fi` : ''}
      fi
  artifacts:
    reports:
      junit: neurolint-results.junit.xml
    paths:
      - neurolint-results.*
    expire_in: 1 week
  only:
    - ${this.config.branch}
  allow_failure: ${!failOnIssues}`;
  }

  /**
   * Generate test job
   */
  private generateTestJob(): string {
    return `test:
  stage: test
  script:
    - |
      if [ -f "package.json" ]; then
        npm test
      fi
  only:
    - ${this.config.branch}`;
  }

  /**
   * Generate deploy job
   */
  private generateDeployJob(): string {
    return `deploy:
  stage: deploy
  script:
    - echo "Deployment stage - customize as needed"
  only:
    - ${this.config.branch}
  when: manual`;
  }

  /**
   * Generate notification jobs
   */
  private generateNotificationJobs(notifications: any): string {
    const jobs = [];
    
    if (notifications.email?.length) {
      jobs.push(`notify-email:
  stage: .post
  script:
    - |
      echo "NeuroLint Analysis completed"
      echo "Build: $CI_PIPELINE_ID"
      echo "Status: $CI_JOB_STATUS"
      # Email notification would be sent here
  only:
    - ${this.config.branch}`);
    }
    
    if (notifications.slack) {
      jobs.push(`notify-slack:
  stage: .post
  script:
    - |
      curl -X POST -H 'Content-type: application/json' \\
        --data "{\\"text\\":\\"NeuroLint Analysis: $CI_PIPELINE_ID - $CI_JOB_STATUS\\"}" \\
        ${notifications.slack}
  only:
    - ${this.config.branch}`);
    }
    
    return jobs.join('\n\n');
  }

  /**
   * Create GitLab CI file
   */
  async createCIFile(pipelineConfig: GitLabPipelineConfig): Promise<boolean> {
    try {
      const ciContent = this.generatePipelineConfig(pipelineConfig);
      
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}/repository/files/.gitlab-ci.yml`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.config.accessToken}`
        },
        body: JSON.stringify({
          branch: this.config.branch,
          content: ciContent,
          commit_message: 'Add NeuroLint CI/CD pipeline',
          encoding: 'text'
        })
      });

      return response.ok;
    } catch (error) {
      console.error('Failed to create GitLab CI file:', error);
      return false;
    }
  }

  /**
   * Trigger GitLab pipeline
   */
  async triggerPipeline(ref: string = this.config.branch, variables: Record<string, string> = {}): Promise<any> {
    try {
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}/pipeline`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.config.accessToken}`
        },
        body: JSON.stringify({
          ref,
          variables: Object.entries(variables).map(([key, value]) => ({
            key,
            value
          }))
        })
      });

      if (response.ok) {
        return await response.json();
      }
      return null;
    } catch (error) {
      console.error('Failed to trigger GitLab pipeline:', error);
      return null;
    }
  }

  /**
   * Get pipeline status
   */
  async getPipelineStatus(pipelineId: number): Promise<any> {
    try {
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}/pipelines/${pipelineId}`, {
        headers: {
          'Authorization': `Bearer ${this.config.accessToken}`
        }
      });

      if (response.ok) {
        return await response.json();
      }
      return null;
    } catch (error) {
      console.error('Failed to get GitLab pipeline status:', error);
      return null;
    }
  }

  /**
   * Get pipeline jobs
   */
  async getPipelineJobs(pipelineId: number): Promise<any[]> {
    try {
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}/pipelines/${pipelineId}/jobs`, {
        headers: {
          'Authorization': `Bearer ${this.config.accessToken}`
        }
      });

      if (response.ok) {
        return await response.json();
      }
      return [];
    } catch (error) {
      console.error('Failed to get GitLab pipeline jobs:', error);
      return [];
    }
  }

  /**
   * Get job logs
   */
  async getJobLogs(jobId: number): Promise<string> {
    try {
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}/jobs/${jobId}/trace`, {
        headers: {
          'Authorization': `Bearer ${this.config.accessToken}`
        }
      });

      if (response.ok) {
        return await response.text();
      }
      return '';
    } catch (error) {
      console.error('Failed to get GitLab job logs:', error);
      return '';
    }
  }

  /**
   * Validate GitLab connection
   */
  async validateConnection(): Promise<boolean> {
    try {
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}`, {
        headers: {
          'Authorization': `Bearer ${this.config.accessToken}`
        }
      });

      return response.ok;
    } catch (error) {
      console.error('Failed to validate GitLab connection:', error);
      return false;
    }
  }

  /**
   * Get project information
   */
  async getProjectInfo(): Promise<any> {
    try {
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}`, {
        headers: {
          'Authorization': `Bearer ${this.config.accessToken}`
        }
      });

      if (response.ok) {
        return await response.json();
      }
      return null;
    } catch (error) {
      console.error('Failed to get GitLab project info:', error);
      return null;
    }
  }

  /**
   * Create webhook
   */
  async createWebhook(webhookUrl: string, events: string[] = ['push', 'merge_requests']): Promise<boolean> {
    try {
      const response = await fetch(`${this.config.gitlabUrl}/api/v4/projects/${this.config.projectId}/hooks`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.config.accessToken}`
        },
        body: JSON.stringify({
          url: webhookUrl,
          push_events: events.includes('push'),
          merge_requests_events: events.includes('merge_requests'),
          tag_push_events: events.includes('tag_push'),
          note_events: events.includes('note'),
          job_events: events.includes('job'),
          pipeline_events: events.includes('pipeline'),
          wiki_page_events: events.includes('wiki_page'),
          enable_ssl_verification: true,
          token: this.config.webhookSecret
        })
      });

      return response.ok;
    } catch (error) {
      console.error('Failed to create GitLab webhook:', error);
      return false;
    }
  }
}

export default GitLabIntegration; 